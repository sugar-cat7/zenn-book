---
title: "いまさらFirestoreのあれやこれやを学ぶ"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## 初めに

Firestore 非常に便利ですが、設計や使い方を間違えるとパフォーマンスが落ちたり、課金額が高額になってしまう可能性があります。
この記事では Firestore についての理解を深めるために、設計、パフォーマンス、コスト、セキュリティ、実際にやってみたことをまとめます。

前提

- リージョンは東京(asia-northeast1)
- Firestore の ネイティブ モード

## 設計編

### コレクションの分割

データ構造を設計する上で、複雑な管理が必要な場合に、単一コレクションを分割し､別コレクションを作る場合があります。

- 容量的に 1 ドキュメント内に非正規化してデータを詰め込めない(ドキュメントサイズの上限 1 MB)
- 親子関係を表現したい

コレクションを分割する上で取る選択肢としては以下の 2 つがあります。

- サブコレクション
  - パスを指定してドキュメントを取得することができる
  - N+1 問題が発生する
  - サブコレクションのドキュメント数が 1000 件を超えると、サブコレクションのドキュメントを取得することができなくなる
  - ホットスポットを作りやすい
- 別コレクション

  - 同階層のコレクションは 1 つのコレクショングループとして扱い処理
  - 親子関係が表現しづらい

これ画像あっても良さそう

### ドキュメントに対する読み取り書き込みの分離

firestore においては特に、1 つのドキュメントに対して高頻度での読み取りや書き込みは推奨されていません。

一般的に CQRS と言われる
コマンドとクエリを分離する設計を採用し、読み取りと書き込みを分けることがあります。

なぜ、1 つのドキュメントに対して高頻度での読み取りや書き込みは推奨されていないのか？

- firestore のデータ レイアウト

  - firestore はドキュメントテーブルとインデックステーブルに分かれています。
  - レプリケーション時の強整合性保証のためにドキュメントテーブルの実体は、Paxos アルゴリズムによってスプリットというパーティションに分割されており、複数のサーバから構成されています。
  - スプリットは負荷が増加すると自動的に作成されるため、単一ドキュメントに対して読み取りや書き込みを行うと、スプリットが増えてしまい、単一ドキュメント上で同時実行するオペレーションの量が高いままで維持され、そのドキュメントでホットスポットが発生する場合があります。

- firestore のトランザクションの話
  　- Firestore はトランザクションを使用して書き込みを行い、読み取り用の共有ロックと書き込み用の排他ロックの取得が必要になります。
  　- そのため、1 つのドキュメントに対して高頻度での読み取りや書き込みを行うと、他のトランザクションはその行のセットに書き込めないため、レイテンシが増加したり、ロック競合エラーが発生したりします。

絵を描く

###　時系列データの管理
Firestore はドキュメント内のすべてのフィールドに自動的にインデックスを作成するため、時系列データの管理には向いていません。
理由：。。。
特に、ドキュメント ID には時系列データを入れないようにして、アクセスがランダムに分散するようにする必要があります。

https://firebase.google.com/docs/firestore/understand-reads-writes-scale?hl=ja#service

## パフォーマンス編

https://firebase.google.com/docs/firestore/best-practices?hl=ja

Cloud Firestore のベスト プラクティスによれば、構造の最適化、クエリの最適化が必要です。

### 構造最適化

- RDB と同じような設計にしない N ＋１の管理
- サブコレクションは使わない
- ホットスポットを作らない
- snapshot と通常のクエリの違いの理解

https://firebase.google.com/docs/firestore/real-time_queries_at_scale?hl=ja#pick_a_database_location_close_to_your_users

## コスト編

Firestore における課金体系は以下の通りです。

https://firebase.google.com/docs/firestore/pricing?hl=ja

公式によれば

> - 読み取り、書き込み、削除を行うドキュメントの数。
> - 集約クエリにより照合されたインデックス エントリの数
> - データベースにより使用されるストレージの容量（メタデータとインデックスのオーバーヘッドを含む）。
> - ネットワーク帯域幅の使用量。

### 読み取り、書き込み、削除を行うドキュメントの数

// table にして欲しい
ドキュメントの読み取り ドキュメント 100,000 点あたり $0.038
ドキュメントの書き込み ドキュメント 100,000 点あたり $0.115
ドキュメントの削除 ドキュメント 100,000 点あたり $0.013

### 集約クエリにより照合されたインデックス エントリの数

https://firebase.google.com/docs/firestore/query-data/aggregation-queries?hl=ja

- `count()`、`sum()`、`avg()`等の集約クエリによって照合されたインデックス エントリの数によって課金されます。
  - 1,000 個ごとに 1 回のドキュメントの読み取りとして課金されます。

### データベースにより使用されるストレージの容量

// table にして欲しい
保存データ 1 GiB のストレージ $0.115 GiB/月

保存データにはメタデータ(ドキュメントの各フィールド値、インデックス)、自動インデックス、および複合インデックスが含まれます。
ドキュメント ID（コレクション ID とドキュメント名を含む）。

具体的なドキュメントサイズ
https://cloud.google.com/firestore/pricing?hl=ja#:~:text=%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81-,%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8%20%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AE%E8%A8%88%E7%AE%97,-%E3%82%92%E3%81%94%E8%A6%A7%E3%81%8F%E3%81%A0

### ネットワーク帯域幅の使用量

- リージョン間の Google Cloud リクエスト
- Google Cloud 外部からのリクエスト

月間使用量 ネットワーク下り（外向き）
世界各地の送信先
（中国とオーストラリアは除く、
香港は含む）
（GB あたり） ネットワーク下り（外向き）
中国の送信先
（香港は除く）
（GB あたり） ネットワーク下り（外向き）
オーストラリアの送信先
（GB あたり） ネットワーク上り（内向き）
0 ～ 10 GB 無料 無料 無料 無料
10 GB ～ 1 TB $0.14 $0.23 $0.19 無料
1 ～ 10 TB $0.14 $0.22 $0.18 無料
10 TB ～ $0.12 $0.20 $0.15 無料

### クエリ最適化

課金体系を踏まえると

https://firebase.google.com/docs/firestore/best-practices?hl=ja

- 複合インデックス等をあまり使わない
- Offset を使わない
- Limit を使う
  - Filter での課金についても触れたい

### その他

- リージョンごとの課金学が違う
- オフライン

## セキュリティ編

## やってみた編

## 参考

https://firebase.google.com/docs/firestore/understand-reads-writes-scale
