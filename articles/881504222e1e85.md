---
title: ""
emoji: "😽"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Container Apps + API Managementで構築するAPI Gateway]
published: false
---




こんにちは、開発チームの石井です。本記事はAI Shift Advent Calendar 2023の?日目の記事になります。

みなさんの環境でもアプリケーション間/サービス間での通信としてRESTやgRPCを利用されていることと思います。
便利ではありますが、テストや他チームからの要請で一部APIをSecureに公開したい！と思われたことはありませんか？

今回の記事では、Container Apps + API ManagementでAPI Gatewayを構築する手順をご紹介します。

構成



※今回は検証用環境の準備のためDeveloper Planを利用します。
本番環境での利用は業務要件等を考慮してご検討ください。

### API Managementとは

Web APIを統合管理するためのプラットフォームです。
Azure上のリソース上に構築されたAPIや、オンプレミスのAPIを統合管理することができ、認証・認可、スロットリングなどを制御することができます。

![Alt text](api-management.png)

今回のデモではContainer Apps上に構築したREST APIを利用しますが、gRPC等でも利用可能です。

### Containers Appsとは

Kubernetes 上に構築されたマネージドサービスで、AKSと異なりクラスター構成や管理の手間が不要でスピーディーアプリケーションの構築が可能なアプリケーション開発に焦点が当てられたサービスです。

2022にGAされた後発なサービスだけあって非常に高機能かつ使いやすいサービスとなっています。

- CNCF OSSが組み込み: Envoy、KEDA、Dapr
- ユーザ認証機能
- カナリアリリース/ABテスト/BlueGreenデプロイメント
- k8sクラスタの管理不要
- Service Connectorによる他Azureリソースとの連携の容易さ

https://learn.microsoft.com/ja-jp/azure/container-apps/overview


## デモ環境の構築






### Resource Groupの作成

適当なリソースグループを作りその中にVnetを作っていきます。
ContainerApps、API Management、Private DNS用にそれぞれサブネットを作っていきます。


### Container Appsの作成

Container AppsにはContainerリソースを管理するContainer Apps Environmentを作成する必要があります。
このEnvironmentに対してサブネットを割り当てることでContainer Appsが利用するネットワークを制御することができます。
※最低でも/27のサブネットを割り当てる必要があります。

![Alt text](container-app-env2.png)

イメージはサンプルのものを利用し、Container Appsを作成します。
Internalに設定することで、Vnet内からのみアクセス可能な環境となっています。
![Alt text](container-app3.png)

デプロイされたらApplication Urlを確認してみます。
成功していればアクセスができないはずです。

![Alt text](container-setting.png)

![Alt text](noaccess.png)

次にプライベートDNSゾーンを作成します。
Vnet内でAPI ManagementとContainer Appsの名前解決を行うために必要となります

作成するプライベートDNSゾーンの「名前」には、コンテナーアプリの「アプリケーションURL」のドメイン部分を指定します。

![Alt text](private-dns-instance-detail.png)

リソースが出来上がったらレコードを作成します。
![Alt text](record.png)

![Alt text](network-link.png)

### API Managementの作成

今回API ManagementにはPublicIPを割り当てAPI Gatewayとして利用します。
その際にインターネットからのアクセス等を制御するためにNSGを割り当てたサブネットに紐づけます。

![NSG](subnet-api-management.png)
![Alt text](subnet-api-management2.png)
https://learn.microsoft.com/ja-jp/azure/api-management/api-management-using-with-vnet?tabs=stv2#configure-nsg-rules

またIPアドレスも取得します。(SKUのStandardで取得しないとAPI Manageentには割り当てられません。)
取得したらconfigulationからDNS名のラベル付けを行います。
![Alt text](ip-dns-name.png)

ここまで準備できたらAPI Managementを作成します。

その際に先ほど作成したサブネットおよびIPアドレスを指定します。

![Alt text](api-management2.png)

リソースを作成したら、API Managementの設定を行います。

container appsをimportします。
![Alt text](api-management-container.png)

importした際に設定したsuffixとgatewayのURLを合わせてアクセスするとコンテナーアプリにアクセスすることができます。
（デフォルトでサブスクリプションが要求されるので一時的に解除しています）
![Alt text](image.png)

![Alt text](image-1.png)

ここまででAPI Management経由Container Appsにアクセスすることができました。

IP制限や流量管理はAPI Managementの機能を利用することで制御することができます。

例えばAPI Management経由の全てのリクエストに IP制限をかけたい場合は下記のようにfilterを設定します。


![Alt text](all-ip.png)

設定以外の IPからあくせすした場合はアクセスが拒否されるようになりました。
![Alt text](no.png)

ここまでで冒頭紹介したこれの実現ができました。




## おまけ

今回は簡易的な実験のために Sample Imageを利用しましたがより実運用に近いような構成も紹介します。


### デモ用のイメージを用意する

今回は Bun+Typescriptで構成された簡易的なREST APIを用意します。

[repo-url]

今回はAzure RegistoryにイメージをPushして、そこから Container Appsにデプロイします。

linux/amd64のイメージを用意します。(Container AppsはArm64のイメージには対応していません)

```bash
$ docker build --pull --platform linux/amd64 -t bun-hello-world .
$ docker tag bun-hello-world devnozomi.azurecr.io/dev
$ docker push devnozomi.azurecr.io/dev
```

registryはPremium出ないとPrivate環境での使用ができないので、今回は簡単のためにPublicにしています。

あとは先ほどの手順でSaple Imageを利用するところを変更してRegistry経由でImageを撮ってきてコンテナ化をします。


### Postgresサーバーの用意

Azure Database for PostgreSQLを用意します。

Developer Planを利用する場合は、Azure Database for PostgreSQLのフレキシブルサーバーを作成する必要があります。

https://learn.microsoft.com/ja-jp/azure/postgresql/flexible-server/overview


サブネットを準備します。
サブネットを委任する必要があります。（Microsoft.DBforPostgreSQL/flexibleServers）
![Alt text](subnet-pg.png)

https://learn.microsoft.com/ja-jp/azure/postgresql/flexible-server/concepts-networking-private#virtual-network-concepts


PostgresサーバーもVnet以外からのアクセスを防ぎたいので、Private access (VNet Integration)を選択します。

![Alt text](network-pg.png)

こちらもcontainer Apps同様にPrivate DNSゾーンを作成します。
Flexible Serverの作成時に同時に自動作成することも可能です。

![Alt text](pg-dns.png)

### Container AppsとAzure Database for PostgreSQLを繋ぐ


このPostgresサーバーとContainer Appsを連携させるために、Service Connectorを利用します。

Service ConnectorはAzure上のリソースとの連携を容易にするための機能です。
これを利用すると環境変数の情報などを自動でContainer Appsに設定することができます。

上記で作成したpostgresサーバーを選択し、Container Appsと連携させます。

Container Apps側で使用するランタイムの環境にあわせて接続情報を設定します。

![Alt text](service-connector.png)


ここまで行うとContainerからPostgresサーバーにアクセスすることができます。

実際にコンテナからアクセスしてみます。
MonitoringのConsoleからコンテナを確認できます。
postgresのサーバー名を指定して`nslookup`してみます。


![Alt text](nslookup.png)

正常に解決できていそうです。

次に手元から直にPostgresサーバーにアクセスしてみます。
これは公開していないのでアクセスできないはずです。
![Alt text](host-psql.png)
できませんでした。正しくVnet内でのみアクセスが制御できていそうです。


次はAPI ManagementからContainer Appsにアクセスし、Container Appsに構築したアプリケーションからPostgresサーバーにアクセスできるか確認します。

ソースはこちらです。
DBにログインしているユーザーの情報を取得するAPIです。

TLSの設定を行うために、Postgresサーバーの証明書をダウンロードしています。
ダウンロードはPortalから行うことができます。
※注意: 今回は一時的なデモアプリのためイメージに証明書を含めていますが、本番環境ではAzure Key Vaultなどに証明書を保存して利用することをおすすめします。
```typescript
import { Hono } from "hono";
import { Pool } from "pg";
import fs from "fs";
const app = new Hono();

const sslConfig = Bun.env.AZURE_POSTGRESQL_SSL
  ? {
      ca: fs.readFileSync("./DigiCertGlobalRootCA.crt.pem"),
    }
  : false;

const pool = new Pool({
  user: Bun.env.AZURE_POSTGRESQL_USER,
  host: Bun.env.AZURE_POSTGRESQL_HOST,
  database: Bun.env.AZURE_POSTGRESQL_DATABASE,
  password: Bun.env.AZURE_POSTGRESQL_PASSWORD,
  port: parseInt(Bun.env.AZURE_POSTGRESQL_PORT!, 10),
  ssl: sslConfig,
});

app.get("/", async (c) => {
  try {
    console.log("Connecting to database");
    const client = await pool.connect();
    try {
      const result = await client.query("SELECT current_user;");
      const currentUser = result.rows.at(0).current_user;
      return c.json({ message: `Hello, ${currentUser}` }, 200);
    } finally {
      client.release();
    }
  } catch (err) {
    if (err instanceof Error) {
      console.error(err);
      return c.json({ error: err.message }, 500);
    }
    console.error("An unknown error occurred");
    return c.json({ error: "An unknown error occurred" }, 500);
  }
});

export default app;
```

```Dockerfile
# use the official Bun image
FROM oven/bun:1 as base
WORKDIR /usr/src/app

# Install common network troubleshooting tools
RUN apt-get update && apt-get install -y \
    curl \
    telnet \
    netcat \
    dnsutils

# install dependencies into temp directory
# this will cache them and speed up future builds
FROM base AS install
RUN mkdir -p /temp/dev
COPY package.json bun.lockb /temp/dev/
RUN cd /temp/dev && bun install --frozen-lockfile

# install with --production (exclude devDependencies)
RUN mkdir -p /temp/prod
COPY package.json bun.lockb /temp/prod/
RUN cd /temp/prod && bun install --frozen-lockfile --production

# copy node_modules from temp directory
# then copy all (non-ignored) project files into the image
FROM base AS prerelease
COPY --from=install /temp/dev/node_modules node_modules
COPY . .

# Copy the DigiCertGlobalRootCA.crt.pem file
COPY DigiCertGlobalRootCA.crt.pem ./

# [optional] tests & build
ENV NODE_ENV=production
RUN bun test
RUN bun run build

# copy production dependencies and source code into final image
FROM base AS release
COPY --from=install /temp/prod/node_modules node_modules
COPY --from=prerelease /usr/src/app/index.ts .
COPY --from=prerelease /usr/src/app/package.json .

# Copy the DigiCertGlobalRootCA.crt.pem file to final image
COPY --from=prerelease /usr/src/app/DigiCertGlobalRootCA.crt.pem ./

# run the app
USER bun
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "run", "index.ts" ]

```

アクセスできました。
![Alt text](api-mabagement-pg.png)



このようにして下記の構成を実現することができました。

### まとめ
